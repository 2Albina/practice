**План и отчёты по практике. **

**Как сделать предварительно откомпилированные заголовочные файлы. Какой
эффект они дают.**

**20.06.2023**

**задача**

Погуглить, изучить статьи по данной теме.

**отчет**

Нашла статьи, где описаны хедеры, для чего нужны, как работают и как их
подключить к проекту.

*Зачем они нужны?*

При компиляции большого количества исходных файлов компилятор, по факту,
выполняет множество раз одну и ту же работу по разбору тяжеловесных
заголовков (например, iostream). Основная идея заключается в том, чтобы
вынести эти тяжеловесные заголовки в отдельный файл, который
компилируется единожды и затем включается во все единицы
трансляции самым первым.

*Как работают?*

Файл, который содержит precompiled headers, имеет расширение ".pch". Имя
файла обычно совпадает с названием проекта. Это и другие используемые
имена можно изменить в настройках. Файл может быть весьма большим и
зависит от того, как много заголовочных файлов в нём раскрыто.

Файл \*.pch возникает после компиляции stdafx.cpp. Файл собирается с
ключом "/Yc". Этот ключ как раз и говорит компилятору, что нужно создать
precompiled headers. Файл stdafx.cpp может содержать одну строчку:
\#include "stdafx.h".

В файле "stdafx.h" находится самое интересное. Сюда нужно включить
заголовочные файлы, которые будут заранее препроцессироваться.

<https://pvs-studio.ru/ru/blog/posts/cpp/0549/>  
<https://pvs-studio.ru/ru/blog/posts/cpp/0265/>  
<https://learn.microsoft.com/ru-ru/cpp/build/creating-precompiled-header-files?view=msvc-170>

**21.06.2023**

**задача**

Создать проект, подключить предкомпилированный хедер, сравнить с
проектом без использования такого хедера.

**отчет**

Создала два проекта *without\_pch* и *with\_pch.* Первый содержит один
.cpp файл, в котором поключены несколько заголовочных файлов. Во втором
также есть один .cpp файл, но заголовки вынесены в отдельный хедер,
называемый предкомпилированным заголовочным файлом.

*Как я создала предкомипированный заголовочный файл в Visual Studio.*

Для всех .cpp файлов включаем использование precompiled headers. Это
делается на вкладке проект -&gt; свойства -&gt; свойства конфигурации
-&gt; c/c++ -&gt; предварительно откомпилированный заголовок:

\* Выставляем для параметра "Precompiled Header" значение "Use (/Yu)".

\* Для параметра "Precompiled Header File" указываем "stdafx.h".

\* Для параметра "Precompiled Header Output File" указываем
"\$(IntDir)\$(TargetName).pch".

Создаём и добавляем в проект файл stdafx.h. В него мы будем включать те
заголовочные файлы, которые хотим заранее препроцессировать.

Создаём и добавляем в проект файл stdafx.cpp. В нём одна единственная
строка: \#include "stdafx.h".

Для файла stdafx.cpp выставляем для параметра "Precompiled Header"
значение "Create (/Yc)".

Заголовочный файл "stdafx.h" должен включаться в \*.c/\*.cpp файл самым
первым.

Включать в "stdafx.h" только те файлы, которые никогда не изменяются или
меняются ОЧЕНЬ редко. Хорошими кандидатами являются заголовочные файлы
системных и сторонних библиотек.

*Сравнение проектов с использование предкомпилированного заголовка и
без.*

Время сборки уменьшилось на 40% (или в 1,67 раз) при использовании предкомпилированного
хедера (было - 2270 мс, стало - 1356 мс)

*Источники:*

[<span
class="underline">https://pvs-studio.ru/ru/blog/posts/cpp/0265/</span>](https://pvs-studio.ru/ru/blog/posts/cpp/0265/)

[<span
class="underline">https://www.youtube.com/watch?v=trMdw6tCHlY</span>](https://www.youtube.com/watch?v=trMdw6tCHlY)

**22.06.2023**

**задача**

1. Добавить в проект *with\_pch* несколько исходных файлов, в которых
используются похожие или разные хэдеры. Подключить предкомпилированный
хедер.

2. То же самое с gcc/clang.

3. С помощью CMake сгенерировать файлы для сборки проектов различными
компиляторами (msvc, gcc, clang).

**отчет**

В процессе выполнения первой задачи.

**23.06.2023**

**задача**

Выполнить первую задачу с предыдущего дня.

**отчет**

Добавила несколько исходных файлов. Теперь проекты *with\_pch* и
*without\_pch* состоят из трёх .cpp файлов. В 1.cpp используются
заголовки iostream, string; в 2.cpp – iostream, string; в 3.cpp –
iostream, vector, algorithm. В проекте *with\_pch* в предкомпилированный
заголовочный файл вынесены все хедеры исходных файлов (iostream string
vector algorithm).

Время сборки проекта *with\_pch* меньше в 2.5 раза времени сборки *without\_pch*  (было: 2.896 с, стало: 1.156 с).

**26.06.2023**

**задача**

Изучить CMake. С его помощью создать инструкции для сборки проектов с
предкомпилированным заголовком и без. Собрать проекты, используя разные
компиляторы (gcc, clang, msvc).

**отчет**

*Что такое CMake*.

*CMake* - кроссплатформенное программное средство автоматизации сборки
программного обеспечения из исходного кода. Не занимается
непосредственно сборкой, а лишь генерирует файлы сборки из
предварительно написанного файла сценария CMakeLists.txt и предоставляет
простой единый интерфейс управления. Помимо этого, способно
автоматизировать процесс установки и сборки пакетов.

CMake может создавать файлы проектов для нескольких
популярных интегрированных средств разработки. Может создавать сценарии
сборки для MSBuild и nmake в Windows, make на Unix-подобных системах.
CMake поддерживает обширный список компиляторов, в который входят в том
числе Clang, GNU GCC, MSVC.

Сборка программы с помощью CMake представляет собой двухэтапный процесс.
На первом этапе стандартные файлы сборки генерируются из файлов
конфигурации (CMakeLists.txt), которые написаны на языке CMake. Затем
задействуются системные инструменты сборки, такие как make, msbuild,
используемые для непосредственной компиляции программ.

*Сборка проекта with\_pch средствами CMake в командеой строке Linux*.

Необходимо в корне дерева исходников разместить файл CMakeLists.txt,
хранящий правила и цели сборки.

*CMakeLists.txt:*
```
# позволит при сборке увидеть время на компиляцию или линковку
set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE "${CMAKE_COMMAND} -E time")
set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK "${CMAKE_COMMAND} -E time")

# позволяет вывести для каждого юнита время каждой фазы компиляции
add_compile_options(-ftime-report)

# название проекта
project(with_pch)
 
# Установка переменной со списком исходников для исполняемого файла
set(SOURCE_LIB stdafx.cpp)
 
# создание статической библиотеки с именем stdafx
add_library(stdafx STATIC ${SOURCE_LIB})

# добавляет заголовочные файлы к PRECOMPILE_HEADERS целевым свойствам stdafx. 
# именованный объект stdafx должен быть создан с помощью такой команды, 
# как add_executable() или add_library(), и не должен быть целевым псевдонимом.
target_precompile_headers(stdafx PUBLIC stdafx.h)

# Установка переменной со списком исходников для исполняемого файла
set(SOURCE_EXE with_pch_1.cpp with_pch_2.cpp with_pch_3.cpp)

# создаёт исполняемый файл с именем main из исходников SOURCE_EXE.
add_executable(main ${SOURCE_EXE})
```

Создадим пустую директорию для временных файлов и перейдём туда.

> belkalia@DESKTOP-A1S40CT:\~/practice\_unix/tmp\_with\$

Теперь запустим команду cmake, передав ей в качестве параметра путь к
папке с исходниками:

> belkalia@DESKTOP-A1S40CT:\~/practice\_unix/tmp\_with\$ cmake ../with\_pch  
> …  
> -- Build files have been written to: /home/belkalia/practice\_unix/tmp\_with

Видим, что в папке появилось несколько временных файлов, необходимых для
сборки проекта.  
Теперь можно запустить непосредственно make:

> belkalia@DESKTOP-A1S40CT:\~/practice\_unix/tmp\_with\$ make  
> \[ 14%\] Building CXX object CMakeFiles/main.dir/with\_pch\_1.cpp.o  
> \[ 28%\] Building CXX object CMakeFiles/main.dir/with\_pch\_2.cpp.o  
> \[ 42%\] Building CXX object CMakeFiles/main.dir/with\_pch\_3.cpp.o  
> \[ 57%\] Linking CXX executable main  
> \[ 57%\] Built target main  
> \[ 71%\] Building CXX object CMakeFiles/stdafx.dir/cmake\_pch.hxx.gch  
> \[ 85%\] Building CXX object CMakeFiles/stdafx.dir/stdafx.cpp.o  
> \[100%\] Linking CXX static library libstdafx.a  
> \[100%\] Built target stdafx

Итак, наша программа собралась.

Чтобы поменять компилятор, необходимо вызвать команду *CMake* с ключом
-D CMAKE\_C\_COMPILER=&lt;name&gt; -D CMAKE\_CXX\_COMPILER=&lt;name&gt;

*В итоге*

С помощью CMake и командной строки Linux мне удалось собрать проекты без
и с использованием предварительно откомпилированного заголовка, также
получилось поменять компиляторы на gcc и clang(по умолчанию - сс), но на
msvc не получается.

А в командной строке windows также не получается собрать проект,
сгенерированный средствами CMake (команды MSBuild и nmake не работают).

Вот что выводится в командой строке windows:

> C:\\Users\\belkalia\\practice\_win\\tmp\_with&gt;cmake ../with\_pch  
> -- Building for: Visual Studio 17 2022  
> …  
> -- Build files have been written to: C:/Users/belkalia/practice\_win/tmp\_with  
> C:\\Users\\belkalia\\practice\_win\\tmp\_with&gt;make  
> MAKE Version 5.43 Copyright (c) 1987, 2019 Embarcadero Technologies, Inc.  
> Fatal: Unable to open makefile  
> C:\\Users\\belkalia\\practice\_win\\tmp\_with&gt;nmake  
> "nmake" не является внутренней или внешней командой, исполняемой программой или пакетным файлом.  
> C:\\Users\\belkalia\\practice\_win\\tmp\_with&gt;msbuild  
> "msbuild" не является внутренней или внешней командой, исполняемой программой или пакетным файлом.

*Источники:*

<https://ru.wikipedia.org/wiki/CMake>

<https://habr.com/ru/articles/155467/>

<https://habr.com/ru/articles/503302/>

<https://cmake.org/cmake/help/latest/command/target_precompile_headers.html>

<https://www.youtube.com/watch?v=8_X5Iq9niDE>

**27.06.2023**

**задача**

Сравнить разные проекты, чтобы выявить эффект precompiled headers.

Сделать так, чтобы сборка с помощью msvc работала.

**отчет**

*Решение проблемы сборки проекта с компилятором msvc.*

Проблема, что не получается собрать проект, используя компилятор msvc,
решается двумя способами:

-   сначала необходимо выполнить такую команду:

call “C:\\Program Files\\Microsoft Visual
Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat”

-   открыть командную строку для разработчиков VS и в ней выполнять
    необходимые команды.

*Сравнение времени сборки проектов: с использование предкомпилированного
заголовочного файла и без.*

<span class="underline">Описание проектов</span>

Каждый проект состоит из трёх .cpp файлов. В 1.cpp подключены заголовки
iostream string; в 2.cpp подключены заголовки iostream string; в 3.cpp
подключены заголовки iostream vector algorithm.

В первом проекте в предкомпилированный хедер вынесены все хедеры
исходных файлов (iostream string vector algorithm). Во втором проекте -
только те хедеры, которые используются в нескольких исходниках (iostream
string). В третьем не используется предкомпилированный хедер.

<span class="underline">Время компиляции и сборки</span>


|                                                                   | **Время в секундах**                          |                                                                                           |                                                   |
|-------------------------------------------------------------------|-----------------------------------------------|-------------------------------------------------------------------------------------------|---------------------------------------------------|
|                                                                   | **Где все хедеры вынесены в отдельный хедер** | **Где в отдельный хедер вынесены хедеры, которые используются в нескольких .cpp файлах ** | **Где не используется предкомпилированный хедер** |
| **Building CXX object CMakeFiles/stdafx.dir/ cmake\_pch.hxx.gch** | 0.002132                                      | 0.000933                                                                                  | \-                                                |
| **Building CXX object CMakeFiles/stdafx.dir/stdafx.cpp.o**        | 0.002466                                      | 0.000924                                                                                  | \-                                                |
| **Linking CXX static library libstdafx.a**                        | 0.000933                                      | 0.000751                                                                                  | \-                                                |
| **Building CXX object CMakeFiles/main.dir/ 1.cpp.o**              | 0.002564                                      | 0.001006                                                                                  | 0.001034                                          |
| **Building CXX object CMakeFiles/main.dir/ 2.cpp.o**              | 0.005811                                      | 0.001287                                                                                  | 0.001023                                          |
| **Building CXX object CMakeFiles/main.dir/ 3.cpp.o**              | 0.003258                                      | 0.001384                                                                                  | 0.001078                                          |
| **Linking CXX executable main**                                   | 0.000809                                      | 0.000715                                                                                  | 0.000741                                          |
| **Итоги по проекту**                                              | 2.275                                         | 1.620                                                                                     | 2.502                                             |


<span class="underline">Выводы из таблицы:</span>

Время компиляции и сборки предкомпилированых хедеров в 1-ом проекте
больше, так как кол-во заголовков в нем больше чем во 2-ом.

Время компиляции .cpp файлов 1-го проекта больше времени других
проектов, поскольку в исходные файлы подключаются заголовочные файлы со
всего проекта.

Если сравнивать 2-ой и 3-ий проект, то можно сказать, что время
компиляции 1.cpp почти не изменилось, возможно, потому что в
предкомпилированном заголовке добавлены только те хедеры, которые
используются в этом исходном файле, а время компиляции 3.cpp
увеличилось, потому что в предкомпилированном хедере добавлен заголовок,
который не используется в данном исходном файле.

Меньше времени на сборку ушло у 2-го проекта. То есть эффективно
использовать precompiled header, в который включены только те
заголовочные файлы, которые используются в нескольких исходных файлах.

**28.06.2023**

**задача**

Оформить отчеты в markdown.

Сравнение проектов сделать более последовательным и понятным.

**отчет**

Оформляла отчёт.


**29.06.2023**

**задача**

Сравнение проектов сделать более последовательным и понятным.

**отчет**

*Сравнение времени сборки проектов: с использование предкомпилированного заголовочного файла и без.*

Рассматривается несколько случаев, которые отличаются разной конфигурацией включения заголовочных файлов в исходные файлы проекта,
чтобы отследить эффект от использования precompiled headers.
Сравниваются два проекта: с использованием предкомпилированного хедера и без.

1) один исходник.

В каждом проекте есть один .cpp файл.

|                            | Без предкомп. хедера | С предкомп. хедером | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|---------------------|-------------------------------------------|
| Время сборки всего проекта | 2,259                | 1,103               | Уменьшение на 51%                         |
| Время компиляции 1.cpp     | 0.000457             | 0.000464            | Увеличение на 1%                          |

Видим, что время сборки проекта уменьшилось на 51%, 
при этом время компиляции исходного файла увеличилось незначительно (на 1%) 
и не повлияло на эфффект от использования предварительного скомпилированного заголовочного файла, 
что говорит об эффективности данного метода.


2) два исходника с одинаковыми заголовками.

В каждом проекте есть два .cpp файла, в которых подключены одни и те же заголовки.
В предкомп. хедер вынесены все заголовки.

|                            | Без предкомп. хедера | С предкомп. хедером | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|---------------------|-------------------------------------------|
| Время сборки всего проекта | 1,887                | 0,892               | Уменьшение на 53%                         |
| Время компиляции 1.cpp     | 0.000748             | 0.000871            | Увеличение на 16%                         |
| Время компиляции 2.cpp     | 0.000868             | 0.000766            | Уменьшение на 12%                         |

Видим, что время сборки проекта уменьшилось на 53%,
следовательно, использование предкомпилированного хедера эффективно.


3) два исходника с частичным совпадением хедеров.

3.1) В каждом проекте есть два .cpp файла, в которых подключены как разные заголовки, так и одинаковые.  
В 1.cpp подключены - iostream, string; в 2.cpp - iostream, vector, algorithm.  
В предкомп. хедер вынесены заголовки со всего проекта, т.е. iostream, string, vector, algorithm.

|                            | Без предкомп. хедера | С предкомп. хедером | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|---------------------|-------------------------------------------|
| Время сборки всего проекта | 1,818                | 0,994               | Уменьшение на 45%                         |
| Время компиляции 1.cpp     | 0.000532             | 0.001664            | Увеличение на 213%                        |
| Время компиляции 2.cpp     | 0.000506             | 0.000738            | Увеличение на 46%                         |

Время сборки уменьшилось на 45%, что говорит об эффективности использования предкомп. хедера.  
Время компиляции исходных файлов увеличилось за счет того, 
что к каждому из них дополнительно подключаются заголовки, 
которые не используются в данном файле. Но это не повлияло на эффективность рассматриваемого метода.

3.2) В каждом проекте есть два .cpp файла, в которых подключены как разные заголовки, так и одинаковые.  
В 1.cpp подключены - iostream, string; в 2.cpp - iostream, vector, algorithm.  
В предкомп. хедер вынесен только общий заголовок, т.е. iostream.

|                            | Без предкомп. хедера | С предкомп. хедером | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|---------------------|-------------------------------------------|
| Время сборки всего проекта | 1,818                | 1,497               | Уменьшение на 18%                         |
| Время компиляции 1.cpp     | 0.000532             | 0.000471            | Уменьшение на 11%                        |
| Время компиляции 2.cpp     | 0.000506             | 0.000495            | Уменьшение на 2%                         |

Время сборки уменьшилось на 18%, т.е. использование предкомп. хедера все также влияет на сборку в лучшую сторону, хотя не так эффективно, как в случае 3.1).

4) два исходника с разными хедерами.

4.1) В каждом проекте есть два .cpp файла, в которых подключены разные заголовки.  
В 1.cpp подключены - string, map; в 2.cpp - iostream, vector, algorithm.  
В предкомп. хедер вынесены заголовки со всего проекта, т.е. iostream, string, map, vector, algorithm.

|                            | Без предкомп. хедера | С одним предкомп. хедером | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|---------------------------|-------------------------------------------|
| Время сборки всего проекта | 1,996                | 1,190                     | Уменьшение на 40%                         |
| Время компиляции 1.cpp     | 0.000684             | 0.001168                  | Увеличение на 71%                         |
| Время компиляции 2.cpp     | 0.000581             | 0.001638                  | Увеличение на 182%                        |

Время сборки уменьшилось на 45%, что по-прежнему говорит об эффективности использования предкомп. хедера.  
Время компиляции исходных файлов увеличилось за счет того, 
что к каждому из них подключаются заголовки, которые не используются в данном файле. 

4.2) В каждом проекте есть два .cpp файла, в которых подключены разные заголовки.  
В 1.cpp подключены - string, map; в 2.cpp - iostream, vector, algorithm.  
Для каждого исходного файла существует отдельный предкомп. заголовочный файл, 
в который вынесены заголовки соответствующего исходного файла.

|                            | Без предкомп. хедера | С 2мя предкомп. хедерами | Эффект при использовании предкомп. хедера |
|----------------------------|----------------------|--------------------------|-------------------------------------------|
| Время сборки всего проекта | 1,996                | 1,880                    | Уменьшение на 6%                          |
| Время компиляции 1.cpp     | 0.000684             | 0.001034                 | Увеличение на 51%                         |
| Время компиляции 2.cpp     | 0.000581             | 0.001442                 | Увеличение на 148%                        |

Время сборки проекта уменьшилось всего на 6%, это говорит о том, что эффективнее использовать только один предкомпилированный заголовок, как в случае 4.1)

*Общий вывод:*  
Использование предкомпилированных заголовков позволяет уменьшить время сборки проекта.
